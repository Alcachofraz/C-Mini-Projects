#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define PI_SIZE 2001 // 2000 dígitos a analisar + \0
#define HASH_SIZE 1000 // Existem 1000 números possíveis (0-999)
#define MAX 4 // Número máximo de dígitos + \0

/**
 * PI CHALLENGE
 */

int is55 = 0;
int i;

int hash[HASH_SIZE]={0};

int cmpfunc (const void * a, const void * b) {
   return ( *(int*)a - *(int*)b );
}

int strToInt (char *a);
void addOccur (int num);

int strToInt (char *a) {
	return atoi(a);
}

void addOccur (int num) {
	if (num==55) {
		printf("\n%d)", i);
		printf("\n%d", num);
		printf("\n%d\n", is55);
	}
	hash[num]++;
	is55 = 0;
}

int main (void) {
	char pi[PI_SIZE];
	strcpy(pi, "14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912983367336244065664308602139494639522473719070217986094370277053921717629317675238467481846766940513200056812714526356082778577134275778960917363717872146844090122495343014654958537105079227968925892354201995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609631859502445945534690830264252230825334468503526193118817101000313783875288658753320838142061717766914730359825349042875546873115956286388235378759375195778185778053217122680661300192787661119590921642019893809525720106548586327886593615338182796823030195203530185296899577362259941389124972177528347913151557485724245415069595082953311686172785588907509838175463746493931925506040092770167113900984882401285836160356370766010471018194295559619894676783744944825537977472684710404753464620804668425906949129331367702898915210475216205696602405803815019351125338243003558764024749647326391419927260426992279678235478163600934172164121992458631503028618297455570674983850549458858692699569092721079750930295532116534498720275596023648066549911988183479775356636980742654252786255181841757467289097777279380008164706001614524919217321721477235014144197356854816136115735255213347574184946843852332390739414333454776241686251898356948556209921922218427255025425688767179049460165346680498862723279178608578438382796797668145410095388378636095068006422512520511739298489608412848862694560424196528502221066118630674427862203919494504712371378696095636437191728746776465757396241389086583264599581339047802759009");
	char temp1[MAX];
	char temp2[MAX-1];
	char temp3[MAX-2];
	for (i=0; i<PI_SIZE-1; i++) {
		if (pi[i+2] != '\0') {
			strncpy(temp1, pi+i, 3);
			temp1[3] = '\0';
			addOccur(strToInt(temp1));
		}
		if (pi[i+1] != '\0') {
			strncpy(temp2, pi+i, 2);
			temp2[2] = '\0';
			if(strcmp(temp2, "55") == 0) is55=1;
			addOccur(strToInt(temp2));
		}
		if (pi[i] != '\0') {
			strncpy(temp3, pi+i, 1);
			temp3[1] = '\0';
			addOccur(strToInt(temp3));
		}
	}
	
	int ct=0;
	int temp=0;
	int largest=0;
	for(i=0; i<HASH_SIZE-1; i++) {
		if((i%9 == 0) && (hash[i] == 1)) printf("A = %d\nB = %lf\n", i, i*2.5);
		if(hash[i] == 0) {
			ct++;
			if (i > (temp%100)*100) printf("C = %d\n", i);
			temp=i;
		}
		if(hash[i] > hash[largest]) largest = i;
		
	}
	qsort(hash, HASH_SIZE, sizeof (int), cmpfunc);
	printf("D = %d\n", hash[0]);
	for(i=0; i<HASH_SIZE-1; i++) {
		if(hash[i] == (hash[10]+44)) {	
			printf("E = %d\n", i);
			break;
		}
	}
	
	/*for(i=0; i<HASH_SIZE-1; i++) {
		printf("%d -> %d\n", i, hash[i]);
	}
	printf("\n\n%d", ct);
	printf("\n\n%d", hash[55]);*/
	
	printf("%d", 399/100);
	
	return 0;
}

